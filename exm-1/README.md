# 实验一：彩色图像修复

### 实验背景

Sergei Mikhailovich Prokudin-Gorskii (1863 - 1944)是一位超越其所在时代的人，早在1907年，他就坚信彩色摄影将成为未来的发展趋势。在当时，由于沙皇的特别许可，他可以周游辽阔的沙俄帝国并拍摄他所看到的事物，包括列夫·托尔斯泰唯一的彩色肖像。他用简单原始的彩色摄影法拍下了很多东西：人、建筑、风景、铁路、桥梁……！

其所采用的彩色摄影法很简单：分别用红、绿、蓝滤光片把每个场景的三次曝光记录到一个玻璃底板上，并设想通过特殊的投影装置将三种颜色的底片叠加显示，从而让观众能够通过彩色照片了解这个幅员辽阔的国家。可惜，他的计划从未实现：他在1918年的十月革命后离开了俄罗斯，再也没有回来。幸运的是，他所拍摄的沙俄帝国最后几年的RGB玻璃板底片保存了下来，并于1948年被美国国会图书馆（LoC）买下。LoC最近将底片数字化，并可以通过网络供公众下载。

### 实验目标

本次实验的目的是利用图像处理技术，基于数字化存储的玻璃底板图像自动生成尽量非虚化的彩色图像。为完成本次实验，你需要从原始图像文件中分割提取三个彩色通道图像，将它们对齐并彼此叠加在一起，最终形成一张RGB彩色图像。美国国会图书馆在其网站上详细说明了他们对这批照片进行复原并创建彩色图像的过程，大家可以参考 http://www.loc.gov/exhibits/empire/making.html。

### 注意事项

* 课程群文件的“实验项目-1”目录中提供了本次实验所需要的数据图像文件。这些图片包括高分辨率版本（.tif）和低分辨率版本（.jpg），其中每张图片中从上到下按照BGR排列三个颜色通道。你的处理程序应以一个玻璃底板图像作为输入，并产生一个单一的彩色图像文件作为输出。
* “实验项目-1”中提供了一份Python代码文件“colorize_skel.py”，该代码展示了最基本的彩色图片复原过程：将图像从上到下分成三个相等的部分，并将第二部分和第三部分(G和R)通过cv.merge()函数叠加到第一部分(B)。执行该代码可以看到输出的彩色图像结果。在实验初期，你应该在目录中选择一个较小的.jpg图像来测试这个版本的代码。
* 上述代码仅仅展示了最基本的处理流程。由于三个颜色通道中的相应像素没有完全对齐，生成的彩色图像存在大量虚化的边缘，清晰度非常低。你需要设计适当的平移处理方法以对齐图像中各个通道的对应像素调整。在此过程中需要考虑两个主要问题：
  * 如何通过程序判断像素是否对齐？如何达到最好或最优的对齐结果？
  * 对于低分辨率和高分辨率图像而言，对齐判断和平移处理算法如何保证适当的执行效率？高分辨图像的像素数量远远高于低分辨率图像，不适当的算法设计可能导致差异极大的处理开销。

### 改进优化

通过本实验，学生应该已经能够生成相对自然真实、尽量非虚化的彩色图像。但它们与LoC网站上的手动修复版本相比可能仍然存在差异。每一张这样的照片修复都要花上大量时间，在Photoshop或其他软件中进行艰苦的工作，调整色彩层次，去除瑕疵，添加对比度等等。我们希望学生可以在前期实验的基础上通过自动化程序做出一些改进以达到更高的图像修复效果。下面列出了一些可以改进的要点，但你也可以提出自己的想法并大胆加以尝试，看看能够达到什么样的效果。

*  自动裁剪：合成彩色图片后，照片的边框会有奇怪的颜色。尝试设计一种自动裁剪边界的方法来移除白色、黑色或其他异常颜色的边框。注意不要只是裁掉每一边的预定义边缘——实际上要尝试检测边缘与图像之间的边界。
* 调整对比度：在合成彩色图片前，对图像的亮度进行重新标定是常用的处理手法。例如，在平均亮度最暗的颜色通道上，其最黑的像素应被标定为0，在平均亮度最亮的颜色通道上，其最亮的像素应被标定为1（对8位图像而言，即255）。重新标定各个通道的亮度后，合成结果可能会有更好的质量。
* 更好的颜色映射：由于老旧的摄影设备的误差，我们并不能断定拍摄原始图像时所用的红色、绿色和蓝色镜头准确对应于RGB颜色空间中的R、G和B通道。可尝试找到一个能产生更真实颜色的映射。
* 更多样的对齐检测算法：除了常规的基于像素相似性的对齐检测算法之外，还可以尝试基于其他特征的对齐算法，例如渐变或边缘。
* 更优的图像校准：除了简单地沿x和y轴平移图像的各个通道之外，还可以实现更加精细的图像校准，例如搜索小规模的变形和旋转。虽然在搜索中增加维度会减慢校准速度，但是这样可能会取得更优的复原效果。

### 实验要求

* 本次实验为必做实验内容，学生应该尝试从头实现几乎所有处理逻辑（不包括读取、写入、显示、移动、转换和调整图像大小的基本功能，这些功能可借助OpenCV操作函数完成）。不允许在代码实现中使用高级函数（例如构造高斯/拉普拉斯金字塔、自动对齐图像、计算像素相似性等），应自主完成相应处理逻辑。
* 每个图像（包括高分辨率和低分辨率图像）的平均处理运行时间应在1-2分钟以内。如果你的程序需要几个小时才能完成，那么应该检查并优化代码。
* 在条件允许的情况下，可以尝试并行化你的代码以提高处理速度，并避免使用太多的FOR循环。
* 输入图像可能是jpg (uint8)或tiff格式(uint16)，在处理程序中应该把所有图像转换为相同的数据格式以便程序进行通用的统一处理。(可查阅OpenCV中数据格式转换的相关函数)。
* 图像的边界可能会影响像素对齐的判断结果，请尝试仅在内部像素上计算并判断对齐。
* 输出图像可存为jpg格式，这可以节省大量的磁盘空间。
* 完成实验报告，对算法实现和效果进行分析描述。“改进优化”部分为选做内容，可根据自身情况进行实现。这部分内容可帮助你获得更好的分数。